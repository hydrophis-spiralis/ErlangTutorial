# Erlang tutorial или введение в Erlang.

Сей текст пишется под впечатлением английского введения в Erlang, которое я прошел на 2/3, но ничерта не понял.
Текст будет моей интерпретацией нескольких обучающих ресурсов по Erlang(типа [этого](http://learnyousomeerlang.com/content)), ответов из Stackoverflow и собственных наблюдений.

## Установка

-	Для простоты буду предполагать, что у вас Linux из семейства Debian, прям как у меня сейчас.
	
	Итак, 
	`sudo apt-get install erlang`

	В качестве IDE я использую Sublime Text 3, если же у меня возникнет желание разобраться с эклипсом и еще чем-нибудь таким - отпишу всенепременнейше.
- Винда? Feel free to explore!

## Ну-с, приступим.

### Шелл.

Erlang - функциональный язык программирования. Nuff said. Вместо инструкций и присваивания - функции и неизменяемые переменные(ну т.е. вообще не переменные).

Поставили уже Erlang? Тогда в консоли пишем erl. Это запустит интерпретатор Эрланга. Код можно уже писать. 

Что хорошего есть в этом интерпретаторе? В нем есть автодополнение.
Еще из него прям сразу не понятно как выйти, чем-то это напоминает vim.
Помощь можно получить, написав `help().`.
Подсказка Эрланга предлагает нажать Ctrl+G.
Если нажать это чудное сочетание, интерпретатор переключится в режим "user switch command".
Вот, собственно, что можно делать в этом режиме(я нажал кнопку `h` для этой штуки):
 
>  --> h
>  c [nn]            - connect to job
>  i [nn]            - interrupt job
>  k [nn]            - kill job
>  j                 - list all jobs
>  s [shell]         - start local shell
>  r [node [shell]]  - start remote shell
>  q                 - quit erlang
>  ? | h             - this message
> --> 

 Очевидно, чтобы выйти, нужно нажать на `q`.

### Основы.

В Erlang все выражения должны заканчиваться точкой и пробелом(переходом на новую строку, табом и т.д.) иначе они не будут выполнены. Можно разделять выражения запятыми, но будет показан результат только последнего из них, хотя будут выполнены все. Этот несколько необычный синтаксис происходит с тех седых времен, когда Erlang был реализован на основе Prolog, который является логическим программным языком.

Теперь открываем интерпретатор(что, еще не открыт?) и пишем-пишем:

> 1> 2 + 15.
> 2> 49 * 100.
> 3> 1892 - 1472.
> 4> 5 / 2.
> 5> 5 div 2.
> 6> 5 rem 2.

Ну как? Обращаем внимание, что бодро обрабатываются как целочисленные, так и типы с точкой. Чтобы устроить целочисленное деление, пользуемся штукой div. Остаток от деления - rem (remainder).

Математические операции подчиняются обычным правилам, скобочки в помощь.

> 7> (50 * 100) - 4999.
> 8> -(50 * 100 - 4999).
> 9> -50 * (100 - 4999).

Можно писать числа в недесятичных системах счисления в формате Base#Value, где Base - основание системы(2-36), Value - значение.


> 10> 2#101010.
> 11> 8#0677.
> 12> 16#AE.


### Неизменные переменные.

Калькулятор - это конечно здорово, но надо куда-то сохранять результаты и для этого есть переменные.
Переменные пишут с большой буквы.
Чтобы объяснить поведение переменных, в принципе хватит вот этих 7 выражений:
> 1> One.
> * 1: переменная 'One' не привязана
> 2> One = 1.
> 1
> 3> Un = Uno = One = 1.
> 1
> 4> Two = One + One.
> 2
> 5> Two = 2.       
> 2
> 6> Two = Two + 1.
> ** exception error: no match of right hand side value 3 - ошибка, нельзя присваивать таким образом
> 7> two = 2.
> ** exception error: no match of right hand side value 2 - еще ошибка

Первый вывод, который можно сделать - присвоить значение переменной можно только один раз, после этого можно вообразить себе, что вы присваиваете значение, если это то же значение, которое уже присвоено переменной. Еслиt оно другое - Erlang будет возмущаться. Объясняется это поведением оператора `=`. Этот оператор помимо присваивания еще и сравнивает значения и ругается, если значения разные. Если они одинаковые, то оператор возвращает значение:

> 8> 47 = 45 + 2.
> 47
> 9> 47 = 45 + 3.
>** exception error: no match of right hand side value 48


Если вдруг вы сделали переменную с не тем названием, её можно удалить таким образом: `f(variable).` Однако работает это только при тестировании в интерпретаторе, в реальных программах оно не сработает.

### Атомы.

Есть причина, по которой переменные не начинаются с маленькой буквы. Причина  называется атомом. Атомы - это литералы-константы со своими собственными именами. Ровно то, что вы видите и ничего больше. Атом `cat` обозначает "cat". Менять нельзя, поломать нельзя. Всё. Deal with it.

Примеры атомов:
1> atom.
atom
2> atoms_rule.
atoms_rule
3> atoms_rule@erlang.
atoms_rule@erlang
4> 'Atoms can be cheated!'.
'Atoms can be cheated!'
5> atom = 'atom'.
atom

Атом должен быть закрыт в одинарные кавычки (') в случае, если он вдруг не начинается с маленькой буквы или содержит пробелы какие-нибудь.

### Булева алгебра

Тут всё просто:

> 1> true and false.
> false
> 2> false or true.
> true
> 3> true xor false.
> true
> 4> not false.
> true
> 5> not (true and true).
> false

А теперь сюрприз. В нормальных языках равенство `==` и неравенство `!=`.
Тут не так. Тут равенство - `=:=`, а неравенство `=/=`. Так-то!

> 6> 5 =:= 5.
> true
> 7> 1 =:= 0.
> false
> 8> 1 =/= 0.
> true
> 9> 5 =:= 5.0.
> false
> 10> 5 == 5.0.
> true
> 11> 5 /= 5.0.
> false

Впрочем, как показывает пример, можно обходиться и `==` для сравнения и `/=` для неравенств.
Да и всё остальное не так сильно отличается:

> 2> 1 < 2.
> true
> 13> 1 < 1.
> false
> 14> 1 >= 1.
> true
> 15> 1 =< 1.
> true

ВНИМАНИЕ! УВАГА! АХТУНГ! ФОРЗИХТ! ГЕФАР!

`true` и `false` - это АТОМЫ. Это конечно специальные атомы, встроенные в интерпретатор. Но это всё-таки атомы. Это означает следующее поведение:

> 13> 5 =:= true.
> false
> 14> 0 == false.
> false
> 15> 1 < false.
> true

Вообще, для подобных ключевых слов-атомов определен порядок. Но зачем он вам, правда?)

### Туплы. Они же Кортежи. Перечисления.

Перечисления - это всё-таки способ хоть как-то организовать данные, сгруппировать их. Синтаксис простейший.
Вот так, к примеру, можно организовать хранение точки из 2-мерного пространства:

> 1> X = 10, Y = 4.
> 4
> 2> Point = {X,Y}.
> {10,4}

Т.е. кортежи можно организовать с помощью фигурных скобок.
А вот так элегантно(как в Python)можно оперировать с данными кортежа:
>3> Point = {4,5}.
>{4,5}
>4> {X,Y} = Point.
>{4,5}
>5> X.
>4
>6> {X,_} = Point.
>{4,5}

Разберем вот это всё поподробнее. В строчке 4> X и Y еще считаются непривязанными переменными, т.е. не имеют значения.
В самой строчке происходит сравнение кортежей {X,Y} и {4,5}.
Эрланг распаковывает кортеж в переменные и после этого сравнение уже {4,5} = {4,5}. Оно, конечно, срабатывает. 
Это один из примеров работы сравнения шаблонов.

Еще, как видно, можно использовать анонимные переменные. Через подчеркивание. Вот через такое: _. Эта переменная всегда не привязана к значению и используется в шаблонах для поиска по шаблонам.
Работает оно так: 

7> {_,_} = {4,5}.
{4,5}
8> {_,_} = {4,5,6}.
** exception error: no match of right hand side value {4,5,6}

Шаблон слева обязан совпадать по количеству элементов с правой частью.

Туплы используются еще и в следующей манере. Предположим, что нам нужно хранить температуру. Можно делать это так: `Temperature = 23.213.`. Еще можно указать, в цельсиях это, кельвинах или фаренгейтах. Туплы тут как раз к месту.
> 10> PreciseTemperature = {celsius, 23.213}.
> 11> {kelvin, T} = PreciseTemperature.
> ** exception error: no match of right hand side value {celsius,23.213}

Получилось вообще удобно. С одной стороны указание единиц измерения, с другой стороны ошибка при неправильном присвоении.
Тупл, который содержит один элемент и после него одно значение, называется "Tagged tuple" - тэгированный тупл.

### Списки

Списки - это соль, хлеб и мякотка большинства функциональных языков.
Используются практически для всего и без сомнения являются самой используемой структурой данных в Erlang.
Списки могут содержать всё вообще. Числа, атомы, туплы, другие списки, ваши самые потаенные мечты. Списки оформляются в квадратные скобки `[element1, ..., elementN]`
Вот, например:
> 1> [1, 2, 3, {numbers,[4,5,6]}, 5.34, atom].
> [1,2,3,{numbers,[4,5,6]},5.34,atom]

Ну есть и свои приколы. Например:
>2> [97, 98, 99].
>"abc"

Это самая презираемая часть Эрланга. Строки. Строки и списки - это одно и то же. Т.е. строки это строки, если интерпретатор так решит. А если не решит, то списки.

Вот почему народ излучает ненависть:
> 3> [97,98,99,4,5,6].
> [97,98,99,4,5,6]
> 4> [233].
> "é"

В первом случае интерпретатор решил, что это у нас не строка, т.к. есть элементы, не похожие на буквы.
А во втором...
Всё потому что Эрланг использовался в телекомах. А телекомам не нужны строки. Так-то.
Впрочем, это печальное недоразумение исправляется - сейчас виртуалка уже потихоньку начинает поддерживать юникод. Впрочем, если хочется много строк, есть zum beispiel Питон.

-------
Слепить два списка? Есть оператор `++`. А вот `--` уберет из списка элементы.

> 5> [1,2,3] ++ [4,5].
> [1,2,3,4,5]
> 6> [1,2,3,4,5] -- [1,2,3].
> [4,5]
> 7> [2,4,2] -- [2,4].
> [2]
> 8> [2,4,2] -- [2,4,2].
> []

Оба оператора ассоциативны вправо, т.е. выполняются справа налево, что ведет вот к такому поведению:

> 9> [1,2,3] -- [1,2] -- [3].
> [3]
> 10> [1,2,3] -- [1,2] -- [2].
> [2,3]

Первый элемент называется "голова"(Head). Все остальные элементы - "хвост"(Tail).
Для извлечения этих частей используются встроенные функции:

> 11> hd([1,2,3,4]).
> 1
> 12> tl([1,2,3,4]).
> [2,3,4]

Встроенные функции обычно реализованы не самим языком, т.к. сложно или невозможно. Вместо этого они реализованы на том же языке, на котором был написан интерпретатор(С/пролог). Некоторые функции могут быть реализованы в Erlang, но встроенными работают быстрее. Например, есть `length(list)`, которая возвращает длину списка.

Доступ к голове или добавление нового элемента крайне просты - почти всегда будет требоваться работать с первым элементом.  Из-за частоты использования есть упрощенный синтаксис доступа к голове: `[Head|Tail]`.
Добавить новый элемент в список можно так:

> 13> List = [2,3,4].
> [2,3,4]
> 14> NewList = [1|List].
> [1,2,3,4]

Во время обработки списков начинаем с первого элемента, хвост же надо будет как-то хранить. Делается это так:

> 15> [Head|Tail] = NewList.
> [1,2,3,4]
> 16> Head.
> 1
> 17> Tail.
> [2,3,4]
> 18> [NewHead|NewTail] = Tail.
> [2,3,4]
> 19> NewHead.
> 2

Вертикальная черта `|` называется конструктором(cons). Список на самом деле можно составить только из конструкторов и значений:

> 20> [1 | []].
> [1]
> 21> [2 | [1 | []]].
> [2,1]
> 22> [3 | [2 | [1 | []] ] ].
> [3,2,1]

Вот эти выражения эквивалентны между собой:

> [a, b, c, d]
> [a, b, c, d | []]
> [a, b | [c, d]]
> [a, b | [c | [d]]]
> [a | [b | [c | [d]]]]
> [a | [b | [c | [d | [] ]]]]

Внимание!
Конструкция вида `[1|2]` сделает т.н. "неправильный" список. Неправильные списки будут работать в случае, когда нужно применить шаблон `[Head|Tail]`, но вот стандартные функции типа length() работать не будут. Это потому, что они ожидают правильные списки. Правильный список - это список, который имеет своим последним элементом пустой список. Когда список объявляется напрямую, как zum beispiel `[2]`, он автоматически формируется правильным. Так что [1|[2]] будет работать! Неправильные списки хоть и валидны, но имеют крайне ограниченное применение.

## Постижение списков

В Erlang можно использовать знакомую по математике нотацию.
Например, 
> 1> [2*N || N <- [1,2,3,4]].
> [2,4,6,8]

Т.е. можно задать некоторую функцию или арифметическое выражение, и применив его к одному списку, получить другой. Синтаксис такой: [expr||list]. Выражение в expr применяется ко всем элементам из list, а разделяются они двумя вертикальными чертами.

Вот еще пример. Допустим, мы хотим видеть в списке четные числа.

> 2> [X || X <- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0].
> [2,4,6,8,10]

Здесь заодно показано, как накладывать ограничения на исходный список. В данном примере есть проверка на четность элемента списка, а `rem` - это оператор остатка от деления.
Практически эту конструкцию используют для того, чтобы решить, к каким элементам списка применять определенное действие. Если вы хоть раз писали запрос на SQL, то это напомнит вам конструкцию WHERE.

Вот еще пример. Допустим, мы выберем из меню кафе только те наименования, которые стоят от 3 до 10 и к каждому добавим 7% налог.

> 3> RestaurantMenu = [{steak, 5.99}, {beer, 3.99}, {poutine, 3.50}, {kitten, 20.99}, {water, 0.00}].
> [{steak,5.99},
> {beer,3.99},
>  {poutine,3.5},
> {kitten,20.99},
> {water,0.0}]
> 4> [{Item, Price*1.07} || {Item, Price} <- RestaurantMenu, Price >= 3, Price =< 10].
> [{steak,6.409300000000001},{beer,4.2693},{poutine,3.745}]

Так что рецепт использования раскрытия списка выглядит так: `NewList = [Expression || Pattern <- List, Condition1, Condition2, ... ConditionN].`
Часть  Pattern <- List называют генератором. Можно использовать больше одного генератора!

Например,
> 5> [X+Y || X <- [1,2], Y <- [2,3]].
> [3,4,4,5]

Такая конструкция запусткает операции `1+2`, `1+3`, `2+2`,`3+3`.

Так что можно пользоваться и вот таким форматом: `NewList = [Expression || GeneratorExp1, GeneratorExp2, ..., GeneratorExpN, Condition1, Condition2, ... ConditionM].`.
Генераторы вместе с подстановкой шаблонов работают как фильтр:

> 6> Weather = [{toronto, rain}, {montreal, storms}, {london, fog},  
> 6>            {paris, sun}, {boston, fog}, {vancouver, snow}].
> [{toronto,rain},
> {montreal,storms},
> {london,fog},
> {paris,sun},
> {boston,fog},
> {vancouver,snow}]
> 7> FoggyPlaces = [X || {X, fog} <- Weather].
> [london,boston]

### Битовый синтаксис.

Т.к. Erlang затачивался под нужды телекома, в нем сделано очень много удобного для манипуляции на уровне битов.

Бинарные данные помещаются в вот такие двойные скобки: `<<`, `>>`, разделяются на читаемые сегменты и каждый сегмент отделяется запятой. Сегмент это последовательность бит, не обязательно выравненная по байтам, хотя это дефолтное. Допустим, мы хотим сохранить оранжевый пиксель в тру-цвете(24 бита):

> 1> Color = 16#F09A29.
> 15768105
> 2> Pixel = <<Color:24>>.
> <<240,154,41>>

Вышенаписанное означает: "положи 16-ричное #F09A29 в 24 бита(красное, зеленое и синее - всё по 8 бит) в переменную Pixel." Значение потом можно взять, в файл записать и т.д. Если действительно записать в файл это значение и потом посмотреть на этот файл через текствый редактор, там будет нечто нечитаемое. Зато когда файл будет прочитан обратно, Erlang интерпретирует данные в этот же самый <<240,151,41>> формат!


