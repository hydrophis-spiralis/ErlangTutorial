# Erlang tutorial или введение в Erlang.

Сей текст пишется под впечатлением английского введения в Erlang, которое я прошел на 2/3, но ничерта не понял.
Текст будет моей интерпретацией нескольких обучающих ресурсов по Erlang(типа [этого](http://learnyousomeerlang.com/content)), ответов из Stackoverflow и собственных наблюдений.

## Установка

-	Для простоты буду предполагать, что у вас Linux из семейства Debian, прям как у меня сейчас.
	
	Итак, 
	`sudo apt-get install erlang`

	В качестве IDE я использую Sublime Text 3, если же у меня возникнет желание разобраться с эклипсом и еще чем-нибудь таким - отпишу всенепременнейше.
- Винда? Feel free to explore!

## Ну-с, приступим.

### Шелл.

Erlang - функциональный язык программирования. Nuff said. Вместо инструкций и присваивания - функции и неизменяемые переменные(ну т.е. вообще не переменные).

Поставили уже Erlang? Тогда в консоли пишем erl. Это запустит интерпретатор Эрланга. Код можно уже писать. 

Что хорошего есть в этом интерпретаторе? В нем есть автодополнение.
Еще из него прям сразу не понятно как выйти, чем-то это напоминает vim.
Помощь можно получить, написав `help().`.
Подсказка Эрланга предлагает нажать Ctrl+G.
Если нажать это чудное сочетание, интерпретатор переключится в режим "user switch command".
Вот, собственно, что можно делать в этом режиме(я нажал кнопку `h` для этой штуки):
 
>  --> h
>  c [nn]            - connect to job
>  i [nn]            - interrupt job
>  k [nn]            - kill job
>  j                 - list all jobs
>  s [shell]         - start local shell
>  r [node [shell]]  - start remote shell
>  q                 - quit erlang
>  ? | h             - this message
> --> 

 Очевидно, чтобы выйти, нужно нажать на `q`.

### Основы.

В Erlang все выражения должны заканчиваться точкой и пробелом(переходом на новую строку, табом и т.д.) иначе они не будут выполнены. Можно разделять выражения запятыми, но будет показан результат только последнего из них, хотя будут выполнены все. Этот несколько необычный синтаксис происходит с тех седых времен, когда Erlang был реализован на основе Prolog, который является логическим программным языком.

Теперь открываем интерпретатор(что, еще не открыт?) и пишем-пишем:

> 1> 2 + 15.
> 2> 49 * 100.
> 3> 1892 - 1472.
> 4> 5 / 2.
> 5> 5 div 2.
> 6> 5 rem 2.

Ну как? Обращаем внимание, что бодро обрабатываются как целочисленные, так и типы с точкой. Чтобы устроить целочисленное деление, пользуемся штукой div. Остаток от деления - rem (remainder).

Математические операции подчиняются обычным правилам, скобочки в помощь.

> 7> (50 * 100) - 4999.
> 8> -(50 * 100 - 4999).
> 9> -50 * (100 - 4999).

Можно писать числа в недесятичных системах счисления в формате Base#Value, где Base - основание системы(2-36), Value - значение.


> 10> 2#101010.
> 11> 8#0677.
> 12> 16#AE.


### Неизменные переменные.

Калькулятор - это конечно здорово, но надо куда-то сохранять результаты и для этого есть переменные.
Переменные пишут с большой буквы.
Чтобы объяснить поведение переменных, в принципе хватит вот этих 7 выражений:
> 1> One.
> * 1: переменная 'One' не привязана
> 2> One = 1.
> 1
> 3> Un = Uno = One = 1.
> 1
> 4> Two = One + One.
> 2
> 5> Two = 2.       
> 2
> 6> Two = Two + 1.
> ** exception error: no match of right hand side value 3 - ошибка, нельзя присваивать таким образом
> 7> two = 2.
> ** exception error: no match of right hand side value 2 - еще ошибка

Первый вывод, который можно сделать - присвоить значение переменной можно только один раз, после этого можно вообразить себе, что вы присваиваете значение, если это то же значение, которое уже присвоено переменной. Еслиt оно другое - Erlang будет возмущаться. Объясняется это поведением оператора `=`. Этот оператор помимо присваивания еще и сравнивает значения и ругается, если значения разные. Если они одинаковые, то оператор возвращает значение:

> 8> 47 = 45 + 2.
> 47
> 9> 47 = 45 + 3.
>** exception error: no match of right hand side value 48


Если вдруг вы сделали переменную с не тем названием, её можно удалить таким образом: `f(variable).` Однако работает это только при тестировании в интерпретаторе, в реальных программах оно не сработает.

### Атомы.

Есть причина, по которой переменные не начинаются с маленькой буквы. Причина  называется атомом. Атомы - это литералы-константы со своими собственными именами. Ровно то, что вы видите и ничего больше. Атом `cat` обозначает "cat". Менять нельзя, поломать нельзя. Всё. Deal with it.

Примеры атомов:
1> atom.
atom
2> atoms_rule.
atoms_rule
3> atoms_rule@erlang.
atoms_rule@erlang
4> 'Atoms can be cheated!'.
'Atoms can be cheated!'
5> atom = 'atom'.
atom

Атом должен быть закрыт в одинарные кавычки (') в случае, если он вдруг не начинается с маленькой буквы или содержит пробелы какие-нибудь.

### Булева алгебра

Тут всё просто:

> 1> true and false.
> false
> 2> false or true.
> true
> 3> true xor false.
> true
> 4> not false.
> true
> 5> not (true and true).
> false

А теперь сюрприз. В нормальных языках равенство `==` и неравенство `!=`.
Тут не так. Тут равенство - `=:=`, а неравенство `=/=`. Так-то!

> 6> 5 =:= 5.
> true
> 7> 1 =:= 0.
> false
> 8> 1 =/= 0.
> true
> 9> 5 =:= 5.0.
> false
> 10> 5 == 5.0.
> true
> 11> 5 /= 5.0.
> false

Впрочем, как показывает пример, можно обходиться и `==` для сравнения и `/=` для неравенств.
Да и всё остальное не так сильно отличается:

> 2> 1 < 2.
> true
> 13> 1 < 1.
> false
> 14> 1 >= 1.
> true
> 15> 1 =< 1.
> true

ВНИМАНИЕ! УВАГА! АХТУНГ! ФОРЗИХТ! ГЕФАР!

`true` и `false` - это АТОМЫ. Это конечно специальные атомы, встроенные в интерпретатор. Но это всё-таки атомы. Это означает следующее поведение:

> 13> 5 =:= true.
> false
> 14> 0 == false.
> false
> 15> 1 < false.
> true

Вообще, для подобных ключевых слов-атомов определен порядок. Но зачем он вам, правда?)

### Туплы. Они же Кортежи. Перечисления.

Перечисления - это всё-таки способ хоть как-то организовать данные, сгруппировать их. Синтаксис простейший.
Вот так, к примеру, можно организовать хранение точки из 2-мерного пространства:

> 1> X = 10, Y = 4.
> 4
> 2> Point = {X,Y}.
> {10,4}

Т.е. кортежи можно организовать с помощью фигурных скобок.
А вот так элегантно(как в Python)можно оперировать с данными кортежа:
>3> Point = {4,5}.
>{4,5}
>4> {X,Y} = Point.
>{4,5}
>5> X.
>4
>6> {X,_} = Point.
>{4,5}

Разберем вот это всё поподробнее. В строчке 4> X и Y еще считаются непривязанными переменными, т.е. не имеют значения.
В самой строчке происходит сравнение кортежей {X,Y} и {4,5}.
Эрланг распаковывает кортеж в переменные и после этого сравнение уже {4,5} = {4,5}. Оно, конечно, срабатывает. 
Это один из примеров работы сравнения шаблонов.

Еще, как видно, можно использовать анонимные переменные. Через подчеркивание. Вот через такое: _. Эта переменная всегда не привязана к значению и используется в шаблонах для поиска по шаблонам.
Работает оно так: 

7> {_,_} = {4,5}.
{4,5}
8> {_,_} = {4,5,6}.
** exception error: no match of right hand side value {4,5,6}

Шаблон слева обязан совпадать по количеству элементов с правой частью.

Туплы используются еще и в следующей манере. Предположим, что нам нужно хранить температуру. Можно делать это так: `Temperature = 23.213.`. Еще можно указать, в цельсиях это, кельвинах или фаренгейтах. Туплы тут как раз к месту.
> 10> PreciseTemperature = {celsius, 23.213}.
> 11> {kelvin, T} = PreciseTemperature.
> ** exception error: no match of right hand side value {celsius,23.213}

Получилось вообще удобно. С одной стороны указание единиц измерения, с другой стороны ошибка при неправильном присвоении.
Тупл, который содержит один элемент и после него одно значение, называется "Tagged tuple" - тэгированный тупл.

### Списки

Списки - это соль, хлеб и мякотка большинства функциональных языков.
Используются практически для всего и без сомнения являются самой используемой структурой данных в Erlang.
Списки могут содержать всё вообще. Числа, атомы, туплы, другие списки, ваши самые потаенные мечты. Списки оформляются в квадратные скобки `[element1, ..., elementN]`
Вот, например:
> 1> [1, 2, 3, {numbers,[4,5,6]}, 5.34, atom].
> [1,2,3,{numbers,[4,5,6]},5.34,atom]

Ну есть и свои приколы. Например:
>2> [97, 98, 99].
>"abc"

Это самая презираемая часть Эрланга. Строки. Строки и списки - это одно и то же. Т.е. строки это строки, если интерпретатор так решит. А если не решит, то списки.

Вот почему народ излучает ненависть:
> 3> [97,98,99,4,5,6].
> [97,98,99,4,5,6]
> 4> [233].
> "é"

В первом случае интерпретатор решил, что это у нас не строка, т.к. есть элементы, не похожие на буквы.
А во втором...
Всё потому что Эрланг использовался в телекомах. А телекомам не нужны строки. Так-то.